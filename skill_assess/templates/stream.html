<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="../static/css/images/logo.ico" type="image/x-icon" />
  <title>Skill Assess</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="../static/css/stream.css" />
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" />
  <script src="https://unpkg.com/wavesurfer.js"></script>
</head>

<body>
  <div class="main-section">
    <div class="custom-div">
      <video class="video-container" width="550px;" height="480px;" id="cameraFeed" autoplay></video>
      <div class="question-container" id="question-container">
        <div id="question"></div>
        <div class="timer" id="timer">00:00</div>
        <div id="questionText"></div> <!-- Updated div for displaying questions -->
        <div id="audio-container">
          <button class="button-start" id="start-recording">Start Recording</button>
          <button class="button-stop" id="stop-recording">Stop Recording</button>
          <audio id="audio-player" controls></audio>
        </div>
      </div>
      <!-- JavaScript -->
      <script>

        // Function to send answer to server
        function sendAnswer(question, answer) {
          fetch('/save-answer', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': '{{ csrf_token }}', // Add CSRF token if CSRF protection is enabled
            },
            body: JSON.stringify({ question: question, answer: answer })
          })
            .then(response => {
              if (response.ok) {
                console.log('Answer saved successfully.');
              } else {
                console.error('Failed to save answer.');
              }
            })
            .catch(error => {
              console.error('Error occurred while saving answer:', error);
            });
        }

        function displayQuestion(question, questionText) {
          document.getElementById("question").innerText = question;
          document.getElementById("questionText").innerText = questionText;
        }

        function startTimer(duration, display) {
          var timer = duration, minutes, seconds;
          return setInterval(function () {
            minutes = parseInt(timer / 60, 10);
            seconds = parseInt(timer % 60, 10);

            minutes = minutes < 10 ? "0" + minutes : minutes;
            seconds = seconds < 10 ? "0" + seconds : seconds;

            display.textContent = minutes + ":" + seconds;

            if (--timer < 0) {
              timer = duration;
              // Display next question or take action when the timer runs out
              questionIndex++;
              if (questionIndex < questions.length) {
                displayQuestion(questions[questionIndex].title, questions[questionIndex].text);
              } else {
                // All questions answered, you can redirect or perform any other action
                // For now, let's just stop the timer
                clearInterval(timerInterval);
              }
            }
          }, 1000);
        }

        // To use the functions
        var questions = {{ questions| safe }}; // Fetching questions from Django context
        var questionIndex = 0;
        displayQuestion(questions[questionIndex].title, questions[questionIndex].text);
        var timerDisplay = document.querySelector("#timer");
        var timerInterval = startTimer(10, timerDisplay); // 10 seconds for each question

        // Audio recording logic (this is a simplified example)
        const startRecordingBtn = document.getElementById("start-recording");
        const stopRecordingBtn = document.getElementById("stop-recording");
        const audioPlayer = document.getElementById("audio-player");

        let mediaRecorder;
        let audioChunks = [];

        // Web Speech API
        const recognition = new webkitSpeechRecognition(); // For compatibility with some browsers
        recognition.continuous = true;
        recognition.interimResults = true;

        recognition.onstart = () => {
          console.log('Speech recognition started.');
        };

        recognition.onresult = (event) => {
          const transcript = Array.from(event.results)
            .map(result => result[0].transcript)
            .join('');
          console.log('Transcript:', transcript);
          sendAnswer(questions[questionIndex].title, transcript);
        };

        recognition.onerror = (event) => {
          console.error('Speech recognition error:', event.error);
        };

        recognition.onend = () => {
          console.log('Speech recognition ended.');
        };

        startRecordingBtn.addEventListener("click", () => {
          audioChunks = [];
          recognition.start();
          startRecordingBtn.disabled = true;
          stopRecordingBtn.disabled = false;
        });

        stopRecordingBtn.addEventListener("click", () => {
          recognition.stop();
          startRecordingBtn.disabled = false;
          stopRecordingBtn.disabled = true;

          // If the recognition is still ongoing, stop it and send the current transcript
          if (recognition.recognizing) {
            recognition.stop();
            const transcript = Array.from(event.results)
              .map(result => result[0].transcript)
              .join('');
            console.log('Transcript:', transcript);
            sendAnswer(questions[questionIndex].title, transcript);
          }
        });

        // Camera code (unchanged)
        navigator.mediaDevices
          .getUserMedia({ video: true })
          .then(function (stream) {
            var videoElement = document.getElementById("cameraFeed");
            videoElement.srcObject = stream;
          })
          .catch(function (error) {
            console.error("Error accessing camera:", error);
          });
        // Video recording logic
        let videoStream;

        startRecordingBtn.addEventListener("click", async () => {
          try {
            videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
            startRecording();
          } catch (error) {
            console.error('Error accessing camera:', error);
          }
        });

        // JavaScript code for sending the recorded video to the server
        stopRecordingBtn.addEventListener("click", () => {
          stopRecording();
          saveVideo().then(() => {
            const formData = new FormData();
            formData.append('video', recordedChunks[0]); // Assuming you're recording one chunk per video
            formData.append('question_number', questionIndex + 1); // Assuming question numbering starts from 1
            fetch('/save-video', {
              method: 'POST',
              body: formData
            })
            .then(response => {
              if (response.ok) {
                console.log('Video saved successfully.');
              } else {
                console.error('Failed to save video.');
              }
            })
            .catch(error => {
              console.error('Error occurred while saving video:', error);
            });
          });
        });

        // Function to save recorded video locally
        function saveVideo() {
          return new Promise(resolve => {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            resolve(blob);
          });
        }
        function saveVideo() {
            return new Promise(resolve => {
              const blob = new Blob(recordedChunks, { type: 'video/webm' });
              resolve(blob);
            });
          }

          function startRecording() {
            mediaRecorder = new MediaRecorder(videoStream);
            const chunks = [];
            mediaRecorder.ondataavailable = event => chunks.push(event.data);
            mediaRecorder.onstop = async () => {
              const blob = new Blob(chunks, { type: 'video/webm' });
              const formData = new FormData();
              formData.append('video', blob);
              formData.append('question_number', questionIndex + 1); // Assuming question starts from 1

              try {
                const response = await fetch('/save-video', {
                  method: 'POST',
                  body: formData
                });
                if (!response.ok) {
                  throw new Error('Failed to save video.');
                }
              } catch (error) {
                console.error('Error occurred while saving video:', error);
              }
            };
            mediaRecorder.start();
          }

          function stopRecording() {
            mediaRecorder.stop();
          }      


      </script>
    </div>
  </div>
</body>

</html>
